{
  "hash": "51892ffd850856356cc61101fcd2b03c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Web Scraping Encyclopaedia Metallum\nauthor: Kevin Miller\ndate: 2024/07/7\noutput: html_document\ncategories: [Python, Web Scraping]\ndescription: A web scraper designed to gather entries on hundreds of thousands of Metal bands. \n---\n\nNote: This is an adapted version of the original `scraper.py` script optimized for Quarto. \n\nAccordingly, the number of bands exported from this file to `metallum_bands.db` or `metallum_bands.csv` may differ slightly from those shown in subsequent analyses. \n\n::: {#ae60f320 .cell execution_count=1}\n``` {.python .cell-code}\n# import necessary libraries\nfrom bs4 import BeautifulSoup\nimport pandas as pd\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.chrome.service import Service as ChromeService\nfrom webdriver_manager.chrome import ChromeDriverManager\nfrom selenium.webdriver import ChromeOptions\nimport time\n```\n:::\n\n\n::: {#8e50e90a .cell execution_count=2}\n``` {.python .cell-code}\n# set options to fine-tune ChromeOptions()\noptions = ChromeOptions()\n# run headless ChromeDriver to avoid popup\noptions.add_argument('--headless=new')\n```\n:::\n\n\n::: {#fc2a2743 .cell execution_count=3}\n``` {.python .cell-code}\n# instantiate Chrome driver with headless browser\ndriver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), \n                          options=options)\n# define base url \nbase_url = 'https://www.metal-archives.com/lists/'\n# instantiate driver from base_url\ndriver.get(base_url)\n```\n:::\n\n\n::: {#bd85c2b7 .cell execution_count=4}\n``` {.python .cell-code}\n# define function to extract band info from each individual page\ndef extract_band_info(page_source):\n    # create BeautifulSoup object to parse HTMl aspects of page\n    soup = BeautifulSoup(page_source, 'html.parser')\n    # locate band info rows and select\n    rows = soup.select('#bandListAlpha tbody tr')\n    \n    # create empty list to append data onto\n    band_info = []\n    \n    # iterate through rows (bands) in page\n    for row in rows:\n        # define entry as dictionary that gets only text aspects\n        # nth preserves increasing tr[] object\n        entry = {\n            'band_name': row.select_one('td:nth-of-type(1) a').text.strip(),\n            'country': row.select_one('td:nth-of-type(2)').text.strip(),\n            'genre': row.select_one('td:nth-of-type(3)').text.strip(),\n            'status': row.select_one('td:nth-of-type(4) span').text.strip()\n        }\n        # append band_info with each entry\n        band_info.append(entry)\n        # return the final band_info\n    return band_info\n```\n:::\n\n\n::: {#ecce2c3d .cell execution_count=5}\n``` {.python .cell-code}\n# define function to extract all bands from letter\ndef extract_bands_from_letter(page_source):\n    # create empty list for all bands in each letter\n    entire_letter_bands = []\n    # set page_source equal to the driver's page_source\n    page_source = driver.page_source\n    # call extract_band_info function on each page and add on to entire_letter_bands\n    entire_letter_bands.extend(extract_band_info(page_source=page_source))\n\n    # instantiate logic\n    while True:\n        try:\n            # define the next button \n            next_button = driver.find_element(By.XPATH, '//*[@id=\"bandListAlpha_next\"]')\n            # if on last page (no next_button), break\n            if 'next paginate_button paginate_button_disabled' in next_button.get_attribute('class'):\n                break \n            # otherwise, click to next page\n            else: \n                next_button.click()\n                # give content a second to load\n                time.sleep(2)\n                # define page_source as the driver's page_source\n                page_source = driver.page_source\n                # recall extract_band_info function as long as still on same letter\n                entire_letter_bands.extend(extract_band_info(page_source=page_source))\n                # add logic to print exception and break\n        except Exception as e:\n            print(f\"Error: {e}\")\n            break\n        # return all bands from the letter\n    return entire_letter_bands\n```\n:::\n\n\n::: {#ad25c657 .cell execution_count=6}\n``` {.python .cell-code}\n# define function to get every band on metallum\ndef extract_all_letters(base_url):\n    # define base url\n    base_url = base_url\n    # define letter list\n    letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    # define character list (NBR would have been evaluated as 'N', 'B', and 'R')\n    characters = ['NBR', '~']\n    # set letters_finished (loop-breaking arg) to False\n    letters_finished = False\n    # set characters_finished (loop-breaking arg) to False\n    characters_finished = False\n    # create empty list for all bands\n    all_bands = []\n    \n    # loop through list of letters\n    for letter in letters:\n        # unless already looped through, then break\n        if letters_finished:\n            break\n        try:\n            # set letter_page as base_url plus the letter\n            letter_page = f\"{base_url}{letter}\"\n            # print the url to monitor progress\n            print(f\"Accessing URL: {letter_page}\")\n            # get driver to access the letter page\n            driver.get(letter_page)\n            # give it 10 if it needs it\n            driver.implicitly_wait(10)\n            # extract the bands in each letter using previous function\n            bands_in_letter = extract_bands_from_letter(driver.page_source)\n            # add entries to all_bands\n            all_bands.extend(bands_in_letter)\n            # if letter is Z (end reached), set loop to break\n            if letter == 'Z':\n                letters_finished = True\n                # print any exceptions\n        except Exception as e:\n            print(f\"Error accessing {letter_page}: {e}\")\n            continue\n        \n    # character function is identical, but loops over the characters instead\n    for character in characters:\n        if characters_finished:\n            break\n        try:\n            # set character_page as base_url plus the character\n            character_page = f\"{base_url}{character}\"\n            # print the url to monitor progress\n            print(f\"Accessing URL: {character_page}\")\n            # get driver to access the character page\n            driver.get(character_page)\n            # give it 10 if it needs it\n            driver.implicitly_wait(10)\n            # extract the bands in each character using previous function\n            bands_in_character = extract_bands_from_letter(driver.page_source)\n            # add entries to all_bands\n            all_bands.extend(bands_in_character)\n            # if character is ~ (end reached), set loop to break \n            if character == '~':\n                characters_finished = True\n                # print any exceptions\n        except Exception as e:\n            print(f\"Error accessing {character_page}: {e}\")\n            continue    \n        \n        # return all the bands from all the letters and characters\n    return all_bands \n```\n:::\n\n\n::: {#723f29d8 .cell execution_count=7}\n``` {.python .cell-code}\n# using extract_all_letters, save all bands to all_bands\nall_bands = extract_all_letters(base_url=base_url)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAccessing URL: https://www.metal-archives.com/lists/A\nAccessing URL: https://www.metal-archives.com/lists/B\nAccessing URL: https://www.metal-archives.com/lists/C\nAccessing URL: https://www.metal-archives.com/lists/D\nAccessing URL: https://www.metal-archives.com/lists/E\nAccessing URL: https://www.metal-archives.com/lists/F\nAccessing URL: https://www.metal-archives.com/lists/G\nAccessing URL: https://www.metal-archives.com/lists/H\nAccessing URL: https://www.metal-archives.com/lists/I\nAccessing URL: https://www.metal-archives.com/lists/J\nAccessing URL: https://www.metal-archives.com/lists/K\nAccessing URL: https://www.metal-archives.com/lists/L\nAccessing URL: https://www.metal-archives.com/lists/M\nAccessing URL: https://www.metal-archives.com/lists/N\nAccessing URL: https://www.metal-archives.com/lists/O\nAccessing URL: https://www.metal-archives.com/lists/P\nAccessing URL: https://www.metal-archives.com/lists/Q\nAccessing URL: https://www.metal-archives.com/lists/R\nAccessing URL: https://www.metal-archives.com/lists/S\nAccessing URL: https://www.metal-archives.com/lists/T\nAccessing URL: https://www.metal-archives.com/lists/U\nAccessing URL: https://www.metal-archives.com/lists/V\nAccessing URL: https://www.metal-archives.com/lists/W\nAccessing URL: https://www.metal-archives.com/lists/X\nAccessing URL: https://www.metal-archives.com/lists/Y\nAccessing URL: https://www.metal-archives.com/lists/Z\nAccessing URL: https://www.metal-archives.com/lists/NBR\nAccessing URL: https://www.metal-archives.com/lists/~\n```\n:::\n:::\n\n\n::: {#70c13b2f .cell execution_count=8}\n``` {.python .cell-code}\n# quit driver\ndriver.quit()\n```\n:::\n\n\n::: {#bf4e78f9 .cell execution_count=9}\n``` {.python .cell-code}\n# convert all_bands to df\nmetallum_df = pd.DataFrame.from_dict(all_bands)\n# create band_id column from index\nmetallum_df['band_id'] = metallum_df.index\n# output df to csv\nmetallum_df.to_csv('data/metallum_bands.csv')\n```\n:::\n\n\n::: {#c9d8719e .cell execution_count=10}\n``` {.python .cell-code}\n# import sqlite and create database 'metallum_bands.db'\nimport sqlite3\nconn = sqlite3.connect('metallum_bands.db')\n# add metallum_df to database\nmetallum_df.to_sql('metal_archives_table', con=conn, if_exists='replace', index=False)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n180137\n```\n:::\n:::\n\n\n::: {#a7b3919d .cell execution_count=11}\n``` {.python .cell-code}\n# commit database changes and close sqlite connection\nconn.commit()\nconn.close()\n```\n:::\n\n\n",
    "supporting": [
      "scraper_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}